# p4testgen seed: 101010
# Date generated: 2023-09-10-11:06:51.114
# Current statement coverage: 0.88
# Traces
# [Parser] MyParser
# [State] start
# [ExtractSuccess] headers.ethernet@0 | Condition: |*packetLen_bits(bit<32>)| >= 112; | Extract Size: 112 -> headers.ethernet.dstAddr = 0x0000_0000_0000 | headers.ethernet.srcAddr = 0x0000_0000_0000 | headers.ethernet.etherType = 0x86DD
# [State] parseIpv6
# [ExtractSuccess] headers.ipv6@112 | Condition: |*packetLen_bits(bit<32>)| >= 304; | Extract Size: 192 -> headers.ipv6.version = 0x0 | headers.ipv6.dscp = 0x00 | headers.ipv6.ecn = 0x0 | headers.ipv6.flowLabel = 0x0000_0000 | headers.ipv6.payloadLength = 0x0000 | headers.ipv6.nextHeader = 0x04 | headers.ipv6.hopLimit = 0x00 | headers.ipv6.srcAddr = 0x0000_0000_0000_0000 | headers.ipv6.dstAddr = 0x3716_66E5_E174_56E6
# [State] parseInnerIpv4
# [ExtractSuccess] headers.innerIpv4@304 | Condition: |*packetLen_bits(bit<32>)| >= 464; | Extract Size: 160 -> headers.innerIpv4.version = 0x0 | headers.innerIpv4.ihl = 0x0 | headers.innerIpv4.diffserv = 0x00 | headers.innerIpv4.totalLen = 0x0000 | headers.innerIpv4.identification = 0x0000 | headers.innerIpv4.flags = 0x0 | headers.innerIpv4.fragOffset = 0x0000 | headers.innerIpv4.ttl = 0x00 | headers.innerIpv4.protocol = 0x58 | headers.innerIpv4.hdrChecksum = 0x0000 | headers.innerIpv4.srcAddr = 0x0000_0000 | headers.innerIpv4.dstAddr = 0x0000_0000
# [State] accept
# [Control MyVerifyChecksum start]
# [Control MyIngress start]
# [mark_to_drop executed.]
# [Table Branch: MyIngress.validate.validate | Key(s): |bmv2_ingress_port(bit<9>)|, |pktvar_2(bit<16>)|, TaintedExpression(bit<12>), TaintedExpression(bit<16>), (bit<1>)0;, (bit<1>)0;, (bit<1>)1;, (bit<1>)1;| Chosen action: MyIngress.validate.setValidated]
# [If Statement]: true -> 1; -> true
# [Internal If Statement]: 0; -> 0; -> false
# [Internal If Statement]: 1; -> 1; -> true
# [Table Branch: MyIngress.route.ipv6Route | Key(s): |pktvar_11(bit<64>)|| Chosen action: MyIngress.route.setForwarding]
# [If Statement]: metadata.l3Protocol == 4 -> |pktvar_20(bit<8>)| == 4; -> false
# [Table Branch: MyIngress.acl.acl Choosing default action: acl_deny_0/deny;]
# [If Statement]: false -> 0; -> false
# [If Statement]: false -> 0; -> false
# [Internal If Statement]: 0 != 0; -> 0 != 0; -> false
# [Control MyEgress start]
# [Control MyUpdateChecksum start]
# [Control MyDeparser start]
# [Emit] headers.ethernet -> headers.ethernet.dstAddr = 0x0000_0000_0000 | headers.ethernet.srcAddr = 0x0000_0000_0000 | headers.ethernet.etherType = 0x86DD
# [Invalid emit: headers.vlan]
# [Invalid emit: headers.ipv4]
# [Emit] headers.ipv6 -> headers.ipv6.version = 0x0 | headers.ipv6.dscp = 0x00 | headers.ipv6.ecn = 0x0 | headers.ipv6.flowLabel = 0x0000_0000 | headers.ipv6.payloadLength = 0x0000 | headers.ipv6.nextHeader = 0x04 | headers.ipv6.hopLimit = 0x00 | headers.ipv6.srcAddr = 0x0000_0000_0000_0000 | headers.ipv6.dstAddr = 0x3716_66E5_E174_56E6
# [Emit] headers.innerIpv4 -> headers.innerIpv4.version = 0x0 | headers.innerIpv4.ihl = 0x0 | headers.innerIpv4.diffserv = 0x00 | headers.innerIpv4.totalLen = 0x0000 | headers.innerIpv4.identification = 0x0000 | headers.innerIpv4.flags = 0x0 | headers.innerIpv4.fragOffset = 0x0000 | headers.innerIpv4.ttl = 0x00 | headers.innerIpv4.protocol = 0x58 | headers.innerIpv4.hdrChecksum = 0x0000 | headers.innerIpv4.srcAddr = 0x0000_0000 | headers.innerIpv4.dstAddr = 0x0000_0000
# [Invalid emit: headers.tcp]
# [Invalid emit: headers.udp]
# [Prepending the emit buffer to the program packet]
# [Internal If Statement]: 511 == 511; -> 511 == 511; -> true
# [Packet marked dropped]

# Table MyIngress.validate.validate
add "MyIngress.validate.validate" 1 "headers.ethernet.etherType":0x86DD "headers.innerIpv4.$valid$":0x1 "headers.ipv4.$valid$":0x0 "headers.ipv6.$valid$":0x1 "headers.vlan.$valid$":0x0 "headers.vlan.etherType":0b**************** "headers.vlan.vlanId":0b************ "standard_metadata.ingress_port":0x0CB "MyIngress.validate.setValidated"()

# Table MyIngress.route.ipv6Route
add "MyIngress.route.ipv6Route" 1 "headers.ipv6.dstAddr":0b00**0111**0*01***11**1*011100101*1**0001**1*0*0001*1**10*110**10 "MyIngress.route.setForwarding"("dstAddr":0x000000000000,"egressPort":0x000)


packet 203 00000000000000000000000086DD00000000000004000000000000000000371666E5E17456E60000000000000000005800000000000000000000C61BC0363C5F5517392869221E6CA0995DEDBC72EF270067AF59CF6BA98E5E7D91341EB40B0F2213CCB39354CCE304194A21AA9A5FB2195FF61A58430114FD369415319B98D5D5F1E52999907631DF01A1B692E5B00857C1662833B43266575D1F30ED8986CB2A4BFD7AAAAB3C28D87546022344C2956DB6575D09FF5A65FA90E69D70EE91CD7A53BE42BDFA902D8B1CB33206415B276BDD1EB15EC0F5A7F155055CC381B4503779D89C8E2F8D3932E53FACB50F6740568CECEB181458598EDC08BCA5C72E6FDF99F9507BFAFA8B3B7A0446DA63E29DB41A5697EEC1271CA2B786C97B4F3E9C4861BB1396A84D6559F093BD09A603E9C7D0EA9DE39DDF397F

