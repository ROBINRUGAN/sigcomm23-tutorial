/* p4obfuscator seed: 987691415 */
error { NoError, PacketTooShort, NoMatch, StackOutOfBounds, HeaderTooShort, ParserTimeout, ParserInvalidArgument } extern packet_in { void extract<T>(out T hdr); void extract< T>(out T variableSizeHeader,in bit<32> variableFieldSizeInBits); T lookahead<T>(); void advance(in bit<32> sizeInBits); bit<32> length(); } extern packet_out { void emit<T>(in T hdr); } extern void verify(in bool check,in error toSignal); @noWarn("unused") action NoAction() { } match_kind { exact, ternary, lpm } extern bool static_assert(bool check,string message); extern bool static_assert(bool check); match_kind { range, optional, selector } const bit<32> __v1model_version = 20180101; @metadata @name("standard_metadata") struct standard_metadata_t { bit<9> ingress_port; bit<9> egress_spec; bit<9> egress_port; bit<32> instance_type; bit<32> packet_length; @alias("queueing_metadata.enq_timestamp") bit<32> enq_timestamp; @alias("queueing_metadata.enq_qdepth") bit<19> enq_qdepth; @alias("queueing_metadata.deq_timedelta") bit<32> deq_timedelta; @alias("queueing_metadata.deq_qdepth") bit<19> deq_qdepth; @alias("intrinsic_metadata.ingress_global_timestamp") bit<48> ingress_global_timestamp; @alias("intrinsic_metadata.egress_global_timestamp") bit<48> egress_global_timestamp; @alias("intrinsic_metadata.mcast_grp") bit<16> mcast_grp; @alias("intrinsic_metadata.egress_rid") bit<16> egress_rid; bit<1> checksum_error; error parser_error; @alias("intrinsic_metadata.priority") bit<3> priority; } enum CounterType { packets, bytes, packets_and_bytes } enum MeterType { packets, bytes } extern counter { counter(bit<32> size,CounterType type); void count(in bit<32> index); } extern direct_counter { direct_counter(CounterType type); void count(); } extern meter { meter(bit<32> size,MeterType type); void execute_meter<T>(in bit<32> index,out T result); } extern direct_meter<T> { direct_meter(MeterType type); void read(out T result); } extern register< T> { register(bit<32> size); @noSideEffects void read(out T result,in bit<32> index); void write(in bit<32> index,in T value); } extern action_profile { action_profile(bit<32> size); } extern void random<T>(out T result,in T lo,in T hi); extern void digest<T>(in bit<32> receiver,in T data); enum HashAlgorithm { crc32, crc32_custom, crc16, crc16_custom, random, identity, csum16, xor16 } @deprecated("Please use mark_to_drop(standard_metadata) instead.") extern void mark_to_drop(); @pure extern void mark_to_drop(inout standard_metadata_t standard_metadata); @pure extern void hash<O,T,D, M>(out O result,in HashAlgorithm algo,in T base,in D data,in M max); extern action_selector { action_selector(HashAlgorithm algorithm,bit<32> size,bit<32> outputWidth); } enum CloneType { I2E, E2E } @deprecated("Please use verify_checksum/update_checksum instead.") extern Checksum16 { Checksum16(); bit<16> get<D>(in D data); } extern void verify_checksum<T, O>(in bool condition,in T data,in O checksum,HashAlgorithm algo); @pure extern void update_checksum<T, O>(in bool condition,in T data,inout O checksum,HashAlgorithm algo); extern void verify_checksum_with_payload<T, O>(in bool condition,in T data,in O checksum,HashAlgorithm algo); @noSideEffects extern void update_checksum_with_payload<T, O>(in bool condition,in T data,inout O checksum,HashAlgorithm algo); extern void clone(in CloneType type,in bit<32> session); @deprecated("Please use 'resubmit_preserving_field_list' instead") extern void resubmit<T>(in T data); extern void resubmit_preserving_field_list(bit<8> index); @deprecated("Please use 'recirculate_preserving_field_list' instead") extern void recirculate<T>(in T data); extern void recirculate_preserving_field_list(bit<8> index); @deprecated("Please use 'clone_preserving_field_list' instead") extern void clone3<T>(in CloneType type,in bit<32> session,in T data); extern void clone_preserving_field_list(in CloneType type,in bit<32> session, bit<8> index); extern void truncate(in bit<32> length); extern void assert(in bool check); extern void assume(in bool check); extern void log_msg(string msg); extern void log_msg<T>(string msg,in T data); parser Parser<H,M> (packet_in b,out H parsedHdr,inout M meta, inout standard_metadata_t standard_metadata); control VerifyChecksum<H,M>(inout H hdr,inout M meta); @pipeline control Ingress<H,M> (inout H hdr,inout M meta,inout standard_metadata_t standard_metadata); @pipeline control Egress<H,M> (inout H hdr,inout M meta,inout standard_metadata_t standard_metadata); control ComputeChecksum<H,M>(inout H hdr,inout M meta); @deparser control Deparser<H>(packet_out b,in H hdr); package V1Switch<H,M> (Parser<H,M> p,VerifyChecksum<H,M> vr,Ingress<H,M> ig,Egress<H,M> eg, ComputeChecksum<H,M> ck,Deparser<H> dep); header ethernet_t { bit<48> dstAddr; bit<48> srcAddr; bit<16> etherType; } header vlan_t { bit<3> pcp; bit<1> dei; bit<12> vlanId; bit<16> etherType; } header ipv4_t { bit<4> version; bit<4> ihl; bit<8> diffserv; bit<16> totalLen; bit<16> identification; bit<3> flags; bit<13> fragOffset; bit<8> ttl; bit<8> protocol; bit<16> hdrChecksum; bit<32> srcAddr; bit<32> dstAddr; } header ipv6_t { bit<4> version; bit<6> dscp; bit<2> ecn; bit<20> flowLabel; bit<16> payloadLength; bit<8> nextHeader; bit<8> hopLimit; bit<64> srcAddr; bit<64> dstAddr; } header udp_t { bit<16> srcPort; bit<16> dstPort; bit<16> hdrLength; bit<16> checksum; } header tcp_t { bit<16> srcPort; bit<16> dstPort; bit<32> seqNo; bit<32> ackNo; bit<4> dataOffset; bit<4> res; bit<8> flags; bit<16> window; bit<16> checksum; bit<16> urgentPtr; } struct headers_t { ethernet_t ethernet; vlan_t vlan; ipv4_t ipv4; ipv6_t ipv6; ipv4_t innerIpv4; tcp_t tcp; udp_t udp; } struct metadata_t { bool validated; bool decap; bool rewrite; bool forward; bit<12> vlan; bit<8> l3Protocol; bit<16> l4SrcPort; bit<16> l4DstPort; bit<48> newDstAddr; bit<8> newTtl; bit<9> egressPort; } parser MyParser(packet_in packet,out headers_t headers, inout metadata_t metadata, inout standard_metadata_t standard_metadata) { state start { metadata.validated = false; metadata.decap = false; metadata.rewrite = false; metadata.forward = false; metadata.vlan = 0; metadata.l3Protocol = 0; metadata.l4SrcPort = 0; metadata.l4DstPort = 0; metadata.newDstAddr = 0; metadata.egressPort = 0; transition parseEthernet; } state parseEthernet { packet.extract(headers.ethernet); transition select( headers.ethernet.etherType) {2048: parseIpv4; 34525: parseIpv6; 33024: parseVlan; default: accept; } } state parseVlan { packet.extract(headers.vlan); transition select( headers.vlan.etherType) {2048: parseIpv4; 34525: parseIpv6; default: accept; } } state parseIpv4 { packet.extract(headers.ipv4); metadata.l3Protocol = headers.ipv4.protocol; transition select( headers.ipv4.protocol) {6: parseTcp; 17: parseUdp; default: accept; } } state parseIpv6 { packet.extract(headers.ipv6); metadata.l3Protocol = headers.ipv6.nextHeader; transition select( headers.ipv6.nextHeader) {4: parseInnerIpv4; 6: parseTcp; 17: parseUdp; default: accept; } } state parseInnerIpv4 { packet.extract(headers.innerIpv4); metadata.l3Protocol = headers.innerIpv4.protocol; transition select( headers.innerIpv4.protocol) {6: parseTcp; 17: parseUdp; default: accept; } } state parseTcp { packet.extract(headers.tcp); metadata.l4SrcPort = headers.tcp.srcPort; metadata.l4DstPort = headers.tcp.dstPort; transition accept; } state parseUdp { packet.extract(headers.udp); metadata.l4SrcPort = headers.udp.srcPort; metadata.l4DstPort = headers.udp.dstPort; transition accept; } } control MyDeparser(packet_out packet,in headers_t headers) { apply { packet.emit(headers.ethernet); packet.emit(headers.vlan); packet.emit(headers.ipv4); packet.emit(headers.ipv6); packet.emit(headers.innerIpv4); packet.emit(headers.tcp); packet.emit(headers.udp); } } control MyVerifyChecksum(inout headers_t headers,inout metadata_t metadata) { apply { verify_checksum(headers.ipv4.isValid(), {headers.ipv4.version,headers.ipv4.ihl, headers.ipv4.diffserv,headers.ipv4.totalLen, headers.ipv4.identification,headers.ipv4.flags, headers.ipv4.fragOffset,headers.ipv4.ttl, headers.ipv4.protocol,headers.ipv4.srcAddr, headers.ipv4.dstAddr}, headers.ipv4.hdrChecksum,HashAlgorithm.csum16); } } control MyUpdateChecksum(inout headers_t headers,inout metadata_t metadata) { apply { update_checksum(headers.ipv4.isValid(), {headers.ipv4.version,headers.ipv4.ihl, headers.ipv4.diffserv,headers.ipv4.totalLen, headers.ipv4.identification,headers.ipv4.flags, headers.ipv4.fragOffset,headers.ipv4.ttl, headers.ipv4.protocol,headers.ipv4.srcAddr, headers.ipv4.dstAddr}, headers.ipv4.hdrChecksum,HashAlgorithm.csum16); } } control Validate(inout headers_t headers,inout metadata_t metadata, inout standard_metadata_t standard_metadata) { action setValidated() { metadata.validated = true; } action setValidatedAndUntag() { metadata.validated = true; metadata.vlan = headers.vlan.vlanId; headers.ethernet.etherType = headers.vlan.etherType; headers.vlan.setInvalid(); } table validate { key = { standard_metadata.ingress_port : exact ; headers.ethernet.etherType : exact ; headers.vlan.vlanId : ternary ; headers.vlan.etherType : ternary ; headers.vlan.isValid() : exact ; headers.ipv4.isValid() : exact ; headers.ipv6.isValid() : exact ; headers.innerIpv4.isValid() : exact ; } actions = { setValidated;setValidatedAndUntag;NoAction; } default_action = NoAction(); } apply { validate.apply(); } } control Route(inout headers_t headers,inout metadata_t metadata, inout standard_metadata_t standard_metadata) { action setForwarding(bit<48> dstAddr,bit<9> egressPort) { metadata.rewrite = true; metadata.forward = true; metadata.newDstAddr = dstAddr; metadata.egressPort = egressPort; } table ipv4Route { key = { headers.ipv4.dstAddr : ternary ; } actions = { setForwarding;NoAction; } default_action = NoAction(); } table ipv6Route { key = { headers.ipv6.dstAddr : ternary ; } actions = { setForwarding;NoAction; } default_action = NoAction(); } action setDecap() { metadata.decap = true; } table decap { key = { headers.ipv6.dstAddr : ternary ; } actions = { setDecap;NoAction; } default_action = NoAction(); } apply { if (headers.ipv4.isValid()) { ipv4Route.apply(); } if (headers.ipv6.isValid()) { ipv6Route.apply(); if ((metadata.l3Protocol == 4)) { decap.apply(); } } } } control Acl(inout headers_t headers,inout metadata_t metadata, inout standard_metadata_t standard_metadata) { action allow() { } action deny() { metadata.forward = false; } table acl { key = { standard_metadata.ingress_port : ternary ; metadata.egressPort : ternary ; metadata.vlan : ternary ; headers.ethernet.srcAddr : exact ; headers.ethernet.dstAddr : exact ; headers.ethernet.etherType : exact ; headers.ipv4.srcAddr : ternary ; headers.ipv4.dstAddr : ternary ; headers.ipv4.ttl : ternary ; headers.ipv6.srcAddr : ternary ; headers.ipv6.dstAddr : ternary ; headers.ipv6.hopLimit : ternary ; metadata.l3Protocol : ternary ; metadata.l4SrcPort : ternary ; metadata.l4DstPort : ternary ; } actions = { allow;deny; } default_action = deny(); } apply { acl.apply(); } } control Rewrite(inout headers_t headers,inout metadata_t metadata, inout standard_metadata_t standard_metadata) { apply { if (metadata.forward) { if (metadata.decap) { headers.ipv4.setValid(); headers.ipv4 = headers.innerIpv4; headers.ethernet.etherType = 2048; headers.ipv6.setInvalid(); } if (metadata.rewrite) { headers.ethernet.dstAddr = metadata.newDstAddr; if (headers.ipv4.isValid()) { headers.ipv4.ttl = (headers.ipv4.ttl - 1); if ((headers.ipv4.ttl == 0)) { metadata.forward = false; } } else if (headers.ipv6.isValid()) { headers.ipv6.hopLimit = (headers.ipv6.hopLimit - 1); if ((headers.ipv6.hopLimit == 0)) { metadata.forward = false; } } } } } } control Forward(inout headers_t headers,inout metadata_t metadata, inout standard_metadata_t standard_metadata) { action setTag(bit<12> vlanId) { headers.vlan.setValid(); headers.vlan.pcp = 0; headers.vlan.dei = 0; headers.vlan.vlanId = vlanId; headers.vlan.etherType = headers.ethernet.etherType; headers.ethernet.etherType = 33024; } table tag { key = { standard_metadata.ingress_port : exact ; } actions = { setTag;NoAction; } default_action = NoAction(); } apply { if (metadata.forward) { tag.apply(); standard_metadata.egress_spec = metadata.egressPort; } } } control MyIngress(inout headers_t headers,inout metadata_t metadata, inout standard_metadata_t standard_metadata) { Validate() validate; Route() route; Acl() acl; Rewrite() rewrite; Forward() forward; apply { mark_to_drop(standard_metadata); validate.apply(headers,metadata,standard_metadata); if (metadata.validated) { route.apply(headers,metadata,standard_metadata); acl.apply(headers,metadata,standard_metadata); rewrite.apply(headers,metadata,standard_metadata); forward.apply(headers,metadata,standard_metadata); } } } control MyEgress(inout headers_t headers,inout metadata_t metadata, inout standard_metadata_t standard_metadata) { apply { } } V1Switch(MyParser(),MyVerifyChecksum(),MyIngress(),MyEgress(), MyUpdateChecksum(),MyDeparser()) main; 
