/* p4obfuscator seed: 987691415 */
#include <core.p4>
#include <v1model.p4>
header ethernet_t { bit<48> dstAddr; bit<48> srcAddr; bit<16> etherType; } header vlan_t { bit<3> pcp; bit<1> dei; bit<12> vlanId; bit<16> etherType; } header ipv4_t { bit<4> version; bit<4> ihl; bit<8> diffserv; bit<16> totalLen; bit<16> identification; bit<3> flags; bit<13> fragOffset; bit<8> ttl; bit<8> protocol; bit<16> hdrChecksum; bit<32> srcAddr; bit<32> dstAddr; } header ipv6_t { bit<4> version; bit<6> dscp; bit<2> ecn; bit<20> flowLabel; bit<16> payloadLength; bit<8> nextHeader; bit<8> hopLimit; bit<64> srcAddr; bit<64> dstAddr; } header udp_t { bit<16> srcPort; bit<16> dstPort; bit<16> hdrLength; bit<16> checksum; } header tcp_t { bit<16> srcPort; bit<16> dstPort; bit<32> seqNo; bit<32> ackNo; bit<4> dataOffset; bit<4> res; bit<8> flags; bit<16> window; bit<16> checksum; bit<16> urgentPtr; } struct headers_t { ethernet_t ethernet; vlan_t vlan; ipv4_t ipv4; ipv6_t ipv6; ipv4_t innerIpv4; tcp_t tcp; udp_t udp; } struct metadata_t { bool validated; bool decap; bool rewrite; bool forward; bit<12> vlan; bit<8> l3Protocol; bit<16> l4SrcPort; bit<16> l4DstPort; bit<48> newDstAddr; bit<9> egressPort; } parser MyParser(packet_in packet,out headers_t headers, inout metadata_t metadata, inout standard_metadata_t standard_metadata) { state start { metadata.validated = false; metadata.decap = false; metadata.rewrite = false; metadata.forward = false; metadata.vlan = 0; metadata.l3Protocol = 0; metadata.l4SrcPort = 0; metadata.l4DstPort = 0; metadata.newDstAddr = 0; metadata.egressPort = 0; transition parseEthernet; } state parseEthernet { packet.extract(headers.ethernet); transition select( headers.ethernet.etherType) {2048: parseIpv4; 34525: parseIpv6; 33024: parseVlan; default: accept; } } state parseVlan { packet.extract(headers.vlan); transition select( headers.vlan.etherType) {2048: parseIpv4; 34525: parseIpv6; default: accept; } } state parseIpv4 { packet.extract(headers.ipv4); metadata.l3Protocol = headers.ipv4.protocol; transition select( headers.ipv4.protocol) {6: parseTcp; 17: parseUdp; default: accept; } } state parseIpv6 { packet.extract(headers.ipv6); metadata.l3Protocol = headers.ipv6.nextHeader; transition select( headers.ipv6.nextHeader) {4: parseInnerIpv4; 6: parseTcp; 17: parseUdp; default: accept; } } state parseInnerIpv4 { packet.extract(headers.innerIpv4); metadata.l3Protocol = headers.innerIpv4.protocol; transition select( headers.innerIpv4.protocol) {6: parseTcp; 17: parseUdp; default: accept; } } state parseTcp { packet.extract(headers.tcp); metadata.l4SrcPort = headers.tcp.srcPort; metadata.l4DstPort = headers.tcp.dstPort; transition accept; } state parseUdp { packet.extract(headers.udp); metadata.l4SrcPort = headers.udp.srcPort; metadata.l4DstPort = headers.udp.dstPort; transition accept; } } control MyDeparser(packet_out packet,in headers_t headers) { apply { packet.emit(headers.ethernet); packet.emit(headers.vlan); packet.emit(headers.ipv4); packet.emit(headers.ipv6); packet.emit(headers.innerIpv4); packet.emit(headers.tcp); packet.emit(headers.udp); } } control MyVerifyChecksum(inout headers_t headers,inout metadata_t metadata) { apply { verify_checksum(headers.ipv4.isValid(), {headers.ipv4.version,headers.ipv4.ihl, headers.ipv4.diffserv,headers.ipv4.totalLen, headers.ipv4.identification,headers.ipv4.flags, headers.ipv4.fragOffset,headers.ipv4.ttl, headers.ipv4.protocol,headers.ipv4.srcAddr, headers.ipv4.dstAddr}, headers.ipv4.hdrChecksum,HashAlgorithm.csum16); } } control MyUpdateChecksum(inout headers_t headers,inout metadata_t metadata) { apply { update_checksum(headers.ipv4.isValid(), {headers.ipv4.version,headers.ipv4.ihl, headers.ipv4.diffserv,headers.ipv4.totalLen, headers.ipv4.identification,headers.ipv4.flags, headers.ipv4.fragOffset,headers.ipv4.ttl, headers.ipv4.protocol,headers.ipv4.srcAddr, headers.ipv4.dstAddr}, headers.ipv4.hdrChecksum,HashAlgorithm.csum16); } } control Validate(inout headers_t headers,inout metadata_t metadata, inout standard_metadata_t standard_metadata) { action setValidated() { metadata.validated = true; } action setValidatedAndUntag() { metadata.validated = true; metadata.vlan = headers.vlan.vlanId; headers.ethernet.etherType = headers.vlan.etherType; headers.vlan.setInvalid(); } table validate { key = { standard_metadata.ingress_port : exact ; headers.ethernet.etherType : exact ; headers.vlan.vlanId : ternary ; headers.vlan.etherType : ternary ; headers.vlan.isValid() : exact ; headers.ipv4.isValid() : exact ; headers.ipv6.isValid() : exact ; headers.innerIpv4.isValid() : exact ; } actions = { setValidated;setValidatedAndUntag;NoAction; } default_action = NoAction(); } apply { validate.apply(); } } control Route(inout headers_t headers,inout metadata_t metadata, inout standard_metadata_t standard_metadata) { action setForwarding(bit<48> dstAddr,bit<9> egressPort) { metadata.rewrite = true; metadata.forward = true; metadata.newDstAddr = dstAddr; metadata.egressPort = egressPort; } table ipv4Route { key = { headers.ipv4.dstAddr : ternary ; } actions = { setForwarding;NoAction; } default_action = NoAction(); } table ipv6Route { key = { headers.ipv6.dstAddr : ternary ; } actions = { setForwarding;NoAction; } default_action = NoAction(); } action setDecap() { metadata.decap = true; } table decap { key = { headers.ipv6.dstAddr : ternary ; } actions = { setDecap;NoAction; } default_action = NoAction(); } apply { if (headers.ipv4.isValid()) { ipv4Route.apply(); } if (headers.ipv6.isValid()) { ipv6Route.apply(); if ((metadata.l3Protocol == 4)) { decap.apply(); } } } } control Acl(inout headers_t headers,inout metadata_t metadata, inout standard_metadata_t standard_metadata) { action allow() { } action deny() { metadata.forward = false; } table acl { key = { standard_metadata.ingress_port : ternary ; metadata.egressPort : ternary ; metadata.vlan : ternary ; headers.ethernet.srcAddr : exact ; headers.ethernet.dstAddr : exact ; headers.ethernet.etherType : exact ; headers.ipv4.srcAddr : ternary ; headers.ipv4.dstAddr : ternary ; headers.ipv4.ttl : ternary ; headers.ipv6.srcAddr : ternary ; headers.ipv6.dstAddr : ternary ; headers.ipv6.hopLimit : ternary ; metadata.l3Protocol : ternary ; metadata.l4SrcPort : ternary ; metadata.l4DstPort : ternary ; } actions = { allow;deny; } default_action = deny(); } apply { acl.apply(); } } control Rewrite(inout headers_t headers,inout metadata_t metadata, inout standard_metadata_t standard_metadata) { apply { if (metadata.forward) { if (metadata.decap) { headers.ipv4.setValid(); headers.ipv4 = headers.innerIpv4; headers.ethernet.etherType = 2048; headers.ipv6.setInvalid(); } if (metadata.rewrite) { headers.ethernet.dstAddr = metadata.newDstAddr; if (headers.ipv4.isValid()) { headers.ipv4.ttl = (headers.ipv4.ttl - 1); if ((headers.ipv4.ttl == 0)) { metadata.forward = false; } } else if (headers.ipv6.isValid()) { headers.ipv6.hopLimit = (headers.ipv6.hopLimit - 1); if ((headers.ipv6.hopLimit == 0)) { metadata.forward = false; } } } } } } control Forward(inout headers_t headers,inout metadata_t metadata, inout standard_metadata_t standard_metadata) { action setTag(bit<12> vlanId) { headers.vlan.setValid(); headers.vlan.pcp = 0; headers.vlan.dei = 0; headers.vlan.vlanId = vlanId; headers.vlan.etherType = headers.ethernet.etherType; headers.ethernet.etherType = 33024; } table tag { key = { standard_metadata.ingress_port : exact ; } actions = { setTag;NoAction; } default_action = NoAction(); } apply { if (metadata.forward) { tag.apply(); standard_metadata.egress_spec = metadata.egressPort; } } } control MyIngress(inout headers_t headers,inout metadata_t metadata, inout standard_metadata_t standard_metadata) { Validate() validate; Route() route; Acl() acl; Rewrite() rewrite; Forward() forward; apply { mark_to_drop(standard_metadata); validate.apply(headers,metadata,standard_metadata); if (metadata.validated) { route.apply(headers,metadata,standard_metadata); acl.apply(headers,metadata,standard_metadata); rewrite.apply(headers,metadata,standard_metadata); forward.apply(headers,metadata,standard_metadata); } } } control MyEgress(inout headers_t headers,inout metadata_t metadata, inout standard_metadata_t standard_metadata) { apply { } } V1Switch(MyParser(),MyVerifyChecksum(),MyIngress(),MyEgress(), MyUpdateChecksum(),MyDeparser()) main; 
